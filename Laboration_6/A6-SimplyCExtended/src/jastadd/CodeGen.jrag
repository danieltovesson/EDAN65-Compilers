/**
 * Simple code generation for the Calc language (EDAN65 course labs).
 * @author Jesper Ã–qvist
 */
aspect CodeGen {

  public void Program.genCode(PrintStream out) {
    out.println(".global _start");
    out.println(".data");
    out.println("buf: .skip 1024");
    out.println();
    out.println(".text");
    out.println("_start:");

    //calling main function.
    out.println("call main");

    //maybe we should be using the predefined helpmethods???

    // Call sys_exit:
    out.println("\t movq $0, %rdi");
    out.println("\t movq $60, %rax");
    out.println("\t syscall");

    for (Function function: getFunctionList()) {
      function.genCode(out);
    }
  }

  public void Function.genCode(PrintStream out) {
    out.println(getName().getID() + ":");
    out.println("\t pushq %rbp");
    out.println("\t movq %rsp, %rbp");
    out.println("\t subq $" + (getCodeBlock().numLocals()*8) + ", %rsp");
    getCodeBlock().genCode(out);
  }

  public void Block.genCode(PrintStream out) {
    for (Stmt stmt : getStatementList()) {
      stmt.genCode(out);
    }
  }

  abstract void Stmt.genCode(PrintStream out);
  public void Declaration.genCode(PrintStream out) {
  }
  public void Assignment.genCode(PrintStream out) {
  }
  public void ReAssignment.genCode(PrintStream out) {
  }
  public void WhileStmt.genCode(PrintStream out) {
  }
  public void IfStmt.genCode(PrintStream out) {
  }
  public void FunctionStmt.genCode(PrintStream out) {
  }
  public void Return.genCode(PrintStream out) {
    getReturn().genCode(out);
    out.println("\t movq %rbp, %rsp");
		out.println("\t popq %rbp");
		out.println("\t ret");
		out.println();
  }

  abstract void Expr.genCode(PrintStream out);
  public void FuncCall.genCode(PrintStream out) {

  }
  public void Mul.genCode(PrintStream out) {

  }
  public void Div.genCode(PrintStream out) {

  }
  public void Mod.genCode(PrintStream out) {

  }
  public void Add.genCode(PrintStream out) {

  }
  public void Sub.genCode(PrintStream out) {

  }
  public void Lesser.genCode(PrintStream out) {

  }
  public void Greater.genCode(PrintStream out) {

  }
  public void LesserEqual.genCode(PrintStream out) {

  }
  public void GreaterEqual.genCode(PrintStream out) {

  }
  public void NotEqual.genCode(PrintStream out) {

  }
  public void Equal.genCode(PrintStream out) {

  }
  public void IdUseExpr.genCode(PrintStream out) {

  }
  public void IntValue.genCode(PrintStream out) {
    out.println("\t movq $" + Integer.parseInt(getINTEGER()) + ", %rax");
  }

  /**
   * Address of local variable variable in the current stack frame.
   */
  syn String IdDecl.address() = "-"+(localIndex()*8)+"(%rbp)";

  /**
   * Local variable counting.
   */
  syn int ASTNode.numLocals() = lastNode().localIndex() - localIndex();

  /**
   * Local variable numbering.
   */
  syn int ASTNode.localIndex() = prevNode().localIndex();
  eq Program.localIndex() = 0;
  eq IdDecl.localIndex() = prevNode().localIndex() + 1;

  inh ASTNode ASTNode.prevNode();
  eq ASTNode.getChild(int i).prevNode() = prevNode(i);
  syn ASTNode ASTNode.lastNode() = prevNode(getNumChild());
  syn ASTNode ASTNode.prevNode(int i) = i>0 ? getChild(i-1).lastNode() : this;

}
