/**
 * Simple code generation for the Calc language (EDAN65 course labs).
 * @author Jesper Ã–qvist
 */
import java.util.Collections;

aspect CodeGen {

  public void Program.genCode(PrintStream out) {
    out.println(".global _start");
    out.println(".data");
    out.println("buf: .skip 1024");
    out.println();
    out.println(".text");
    out.println("_start:");
    out.println();
    //calling main function.
    out.println("call main");

    // Call sys_exit:
    out.println("movq $0, %rdi");
    out.println("movq $60, %rax");
    out.println("syscall");
    out.println();

    for (Function function: getFunctionList()) {
      function.genCode(out);
    }
  }

  public void Function.genCode(PrintStream out) {
    out.println(getName().getID() + ":");
    out.println("\t pushq %rbp");
    out.println("\t movq %rsp, %rbp");
    out.println("\t subq $" + (getCodeBlock().numLocals()*8) + ", %rsp");
    getCodeBlock().genCode(out);
  }

  public void Block.genCode(PrintStream out) {
    for (Stmt stmt : getStatementList()) {
      stmt.genCode(out);
    }
  }

  abstract void Stmt.genCode(PrintStream out);
  public void Declaration.genCode(PrintStream out) {
  }
  public void Assignment.genCode(PrintStream out) {
    out.print("\t movq ");
    getValue().genCode(out);
    out.print(", " + getName().address());
    out.println();
  }
  public void ReAssignment.genCode(PrintStream out) {
  }
  public void WhileStmt.genCode(PrintStream out) {
  }
  public void IfStmt.genCode(PrintStream out) {
  }
  public void FunctionStmt.genCode(PrintStream out) {
    getName().genCode(out);
  }
  public void Return.genCode(PrintStream out) {
    out.print("\t movq ");
    getReturn().genCode(out);
    out.print(", %rax");
    out.println();
    out.println("\t movq %rbp, %rsp");
    out.println("\t popq %rbp");
		out.println("\t ret");
		out.println();
  }

  abstract void Expr.genCode(PrintStream out);
  public void FuncCall.genCode(PrintStream out) {

    for (int i = 0; i < getNumExpr(); i++) {
      Expr expr = getExpr(i);
      out.print("\t movq ");
      expr.genCode(out);
      out.print(", " + (-8)*(i+1) + "(%rbp)");
      out.println();
    }

    for (int i = getNumExpr()-1; i >= 0; i--) {
      Expr expr = getExpr(i);
      out.println("\t pushq " + (-8)*(i+1) + "(%rbp)");
    }
    out.println("\t call " + getName().getID());
    out.println("\t addq $" + getNumExpr()*8 + ", %rsp");
  }
  public void Mul.genCode(PrintStream out) {

  }
  public void Div.genCode(PrintStream out) {

  }
  public void Mod.genCode(PrintStream out) {

  }
  public void Add.genCode(PrintStream out) {
    //test code, has to be implemented.
    out.print("$3");
  }
  public void Sub.genCode(PrintStream out) {

  }
  public void Lesser.genCode(PrintStream out) {

  }
  public void Greater.genCode(PrintStream out) {

  }
  public void LesserEqual.genCode(PrintStream out) {

  }
  public void GreaterEqual.genCode(PrintStream out) {

  }
  public void NotEqual.genCode(PrintStream out) {

  }
  public void Equal.genCode(PrintStream out) {

  }
  public void IdUseExpr.genCode(PrintStream out) {
    getName().genCode(out);
  }
  public void IdUse.genCode(PrintStream out) {
    out.print(decl().address());
  }
  public void IntValue.genCode(PrintStream out) {
    out.print("$" + Integer.parseInt(getINTEGER()));
  }

  /**
   * Address of local variable variable in the current stack frame.
   */
  syn String IdDecl.address() = "-"+(localIndex()*8)+"(%rbp)";

  /**
   * Local variable counting.
   */
  syn int ASTNode.numLocals() = lastNode().localIndex() - localIndex();

  /**
   * Local variable numbering.
   */
  syn int ASTNode.localIndex() = prevNode().localIndex();
  eq Program.localIndex() = 0;
  eq IdDecl.localIndex() = prevNode().localIndex() + 1;

  inh ASTNode ASTNode.prevNode();
  eq ASTNode.getChild(int i).prevNode() = prevNode(i);
  syn ASTNode ASTNode.lastNode() = prevNode(getNumChild());
  syn ASTNode ASTNode.prevNode(int i) = i>0 ? getChild(i-1).lastNode() : this;

}
